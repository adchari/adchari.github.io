---
layout: default
title: Learning About Machines
tagline: Adventures in CS
description: My observations.
---

# Learning About Machines

### The Usefulness of Internships

​	Summer has finally rolled around, and the majority of students choose to pursue an internship, research work, or take classes. Of course, others choose to spend their summers relaxing or working a job, but for a CS undergraduate, this potentially gets you less money and even less experience. Therefore, the internship search starts as soon as students get on campus, and continues for the entire school year. But why exactly is this a valuable experience?

​	The age-old adage of the intern getting people coffee might be true in other industries, but the work done by software engineering interns (or data science, CompE, etc.) is really quite different. There are essentially two schools of thought when it comes to this. On one hand, interns could be assigned their own projects, which they will eventually need to present. This can be an individually developed project, or something minor the company needs to get done. This is how Google’s Engineering Practicum works, as well as Facebook’s freshman program, and many others. However, the arguably more useful internship experience is getting assigned to a real team working on a current project. This engrosses you in the reality of a software development life-cycle, exposes you to a multitude of tools, and offers a huge boost to a resume. 

​	Compared to individual projects, this obviously gives you a better experience of what it’s like to work in a large team, on a huge code base, and using tools designed to scale for thousands of users. For example, I might make a small web app for a side project, but the techniques I use are not realistic for an application at scale. I would have to learn how to use containerization, push these containers to the cloud, guarantee uptime, scale up with Kubernetes, etc. There is so much more that goes into this than one would think, and you can’t learn it all on your own as easily as picking it up while working.

​	In addition, classes, even those that include heavy applications of the material, tend not to consider these issues, and often have students working in much smaller groups. This encourages a hole in your CS education, but an internship or two will prepare you for the realities of the workforce. That, in short, is the true usefulness of an internship.

### Open Source and You

​	Open source technologies have been on a rise in popularity since the original advent of the Linux operating system, and are ubiquitous specifically in our field. Developers use git, Docker, Kubernetes, Visual Studio Code, TensorFlow, and Hyperledger every day, and even if your workflow doesn't include any of these tools, it is extremely likely that you are exposed to some open source code at some point in your day. AWS servers run Linux, possible one of the most famous open source projects ever developed, meaning that every time you launch Netflix, the development of these technologies affects you. This might not be the year of the Linux desktop, but it's been the year of the Linux server for decades. Why is open source software so common though?

​	Cooperation makes the world go round. Imagine that your codebase is proprietary, then you can only really allow a couple of teams to work on it at the same time. On the other hand. an open source project can be simultaneously developed by thousands of people all over the world. In the age of decentralized technologies, open source is the original. In addition, if the product is originally developed by a company, releasing it to the public allows for better scrutiny, new features, and improves it for internal use as well. It also allows people to build new and interesting projects using your code as a starting point, and that is useful for everyone. 

​	Security is always growing in importance as computing power increases and there are even more projects to break. Releasing your code online allows  many people to catch program breaking errors, actually generating more secure code. It might be sad to say, but most software developers don't have a very good idea of security, but there are many security professionals who regularly add to Github projects. While it may seem counterintuitive, it is easier to get secure code by releasing it to the public than by leaving it as proprietary code (barring sensitive information or proprietary algorithms).

​	Finally, the quality of code can be heavily improved by allowing many developers to check each other's work, write cleaner code, etc. This might be slightly overlooked, but open source developers are also maintainers of projects, updating and upgrading every aspect of their codebase consistently for the good of other developers. 

​	So why is this useful for education? I feel that there is not enough emphasis on both using and creating open source projects. University education often becomes ubiquitous with studying out of an expensive textbook, but this simply isn't effective for many CS subjects. At the very least, students need to work on their own projects, but until students need to use popular, publicly available development tools, they won't gain experience similar to a corporate environment until they learn to implement open source tools in their code. Our classes shouldn't only teach theory, but implementation with these publicly available tools, like Docker and Kubernetes. 

​	Finally, it makes more sense to teach students open source tools, as these are going to be used more in the workforce, and it also is actually free. It usually makes sense to use a free, well-supported, piece of software over proprietary tools. 

### Pair Programming

​	Pair programming is a fairly common agile programming technique, and has been used in industry for years. It is well known and researched, and most papers cite a slower pace but a better final product, with a higher score on testing suites. Understandably, if this is a major industry trend, working with partners or in small groups is a vital part of a CS education, but how can it be implemented to ensure effective learning and equal workloads?

​	We have all had really poor group project experiences. Sometimes, a partner doesn't put in a fair share of work, or one member of the group takes the entire project and completes it. These reduce learning and create a poor image of group work in students' minds. However, thanks to many technical tools, there are easy ways to work collaboratively that can improve this experience.

​	First, before exploring theories that may or may not succeed, we should start with well-researched and documented techniques for encouraging and enforcing group projects. In particular, the tried-and-true method of simply assigning a project to two or more people is decently effective, at least in terms of the project being completed, but adding a peer review component can improve this system even further. According to a paper by [Noel LeJeune][1], the subjectivity of grading can be a turn off to some teachers, but adding the peer review component allows you to accordingly adjust grades. This is clearly a better solution than both students just getting the same grade, as you can account for partners who were overbearing, unhelpful, or unexpected situations.

​	Pair programming as defined by Agile and in industry is also decently common. When the project is on one computer, students naturally gravitate towards this "paired" style, as only one person can type. However, there are obvious pitfalls. It is less efficient in the short term, as each programmer is only writing code for half the time. However, time is not the factor that we are concerned with. Students easily get lost in small bugs, and often have trouble interpreting the specification of a project. This provides justification for using pair programming in classroom settings, since well-paired students can help each other with these issues. 

​	However, a mismatched pair can result in an unequal workload, communication issues, or even cause grading dilemmas. Due to these issues, optimizing a partnership is the most important factor to a successful pair project. Of course, some research on this subject could potentially improve pair programming as an educational tool. Similarly, a study that compares student understanding through a partner project with understanding after an individual project could confirm the anecdotal advice that group projects help people learn better, especially since the prevailing student belief is often that group projects are a burden.


[1]:https://dl.acm.org/citation.cfm?id=1181843 "Assessment of Individuals on CS Group Projects"

### Academia

​	Especially in CS, there is a huge salary delta between industry developers and academics. Any professor at MIT, Stanford, Berkeley, CMU, or any other university is there DESPITE the fact that with their degree and research experience, they could be making almost double elsewhere. Professors are still at universities because they enjoy research, and some enjoy teaching, but the fundamental issue is that this is not an attractive career path. This means we get some of the brightest minds, but there are still more out there, who were turned off by the lack of tenure-track positions or the salary.

​	This is obviously an issue for many reasons. Particularly, in 2019, there is a consistent shortage of new CS PhDs who go into academia, resulting in classes of 900 students at top universities. Issues like this are a simple question of supply and demand, as the supply of CS PhDs is low in the first place, and when you turn that into PhDs who want to take their degree and work for a university, that drops even more. Demand, of course, is increasing rapidly, as more high school students are attracted to the field through buzzwordy articles in the news, high school CS courses, or a draw to the career paths that can stem from a CS degree. This is resulting in a significant shortage, and there seem to be two ways to rectify this issue. Make the admissions process even more selective, or find more professors. 

​	Obviously, the first option isn't really ideal at all. The admissions process for CS degrees is already intensely competitive, and while competition breeds amazing programmers, it also prevents many amazing minds from entering our field. People who are passionate about CS should get the opportunity to pursue that passion, and while the career outlook for programming jobs is increasing, universities should also continue to open their doors to more and more students. This is understandably idealized, but universities have continued to accept more CS students every year from different backgrounds, nationalities, and genders. Restricting this growth now, while change is imminent in tech, would be catastrophic. The industry and academia would stifle when we most need growth, and it is not realistic to significantly reduce the number of CS students.

​	The other alternative is also interesting, as with an ever-increasing number of CS students and graduates, there should be an increasing number of professors. However, the growth rates for CS academics compared to CS graduates is lackluster.

​	With few open tenure-track and teaching-track faculty positions open, academia becomes a less desirable career again. The fear of going through six years of research and not getting into the academic career you want is one that is extremely unattractive.

​	So how can we solve this? Universities can continue to hire more and more faculty, especially on the teaching-line, as these professors will be helpful in educating a new generation of CS students. However, tenure-track positions and comparable salaries must also be introduced in order to attract these new students into academia. In addition, allowing industry professionals to step in to teach certain classes will allow students to get more insight and real world anecdotes, alongside the more academic or research oriented information from their other professors. Together, we can educate and influence generation after generation of students, as one day, our systems, networks, applications, and research labs will be taken over by these students. The only way to progress is by digress from the current trend.

### Issues with Theory

​	Theoretical computer science is theoretically a really interesting field. It's a combination of math, algorithm design, and thinking about the essence of computing, and yet students stray away from it quickly. At the University of Illinois, the theory and algorithm design classes are revered as some of the hardest and most time-consuming classes. The lack of attraction to theoretical CS is not a good thing, even if only some small percentage of students will actually go into the field, because regardless of what field of CS you enter, algorithms and theory will play an important role. 

​	Consider the modulus operator. It seems harmless, just another way to get a remainder, but its roots stem from the idea of modular arithmetic. While a software engineer may never need to use this, it also might come in handy for actions that repeat every x times. This is a simple use, and something built into many programming languages, but it saves time.

​	Theory also plays a role in ideas like searching and sorting. Every CS class spends some time talking about these algorithms, and they're some of the first we encounter, but there is an advantage to using a more complex function. Some of these sorts will be faster than others, giving your project more overhead and using your resources better. Simple functions like this can play a huge role in how an app performs on a poorly optimized device, and algorithm analysis as a whole plays a large role in designing and executing code that is truly useful. In a game, it might help framerates, in an app, it will reduce latency, and in any web application, reduced need for resources will save you money.

​	So, if theory is so important in all of these fields, and in many more, including areas like cryptography and AI/ML, why is it overlooked?

​	Why do programmers all over the world devalue a college education in the field? Most CS degrees include a portion of theory and mathematics, as well as other important topics, but there is a certain shortsightedness in the way we look at education. The same idea from high school of "this won't do anything for me in the future" is now appearing in colleges. You might never use details from classes, but every aspect of a CS education is important in some way, and can help you one day. Even remembering the smallest idea from your algorithm design class may make your next project better, or remembering some aspect of system design might help improve your web app. These concepts shouldn't be shunned as a waste of time, even if you aren't interested in that particular field, because all these ideas are connected in some way. Every Android app runs on a kernel and an OS, and every programming languages draws from the theory behind it to a large extent. These ideas can improve your knowledge and help solve even greater problems, all while making you a more well rounded programmer. 

​	People always talk about the "value" of a college education, and that's understandable. In our world today, with MOOCs, code bootcamps, and the internet, is there still a role for the college-educated programmer? More and more people get into large software companies from bootcamps that claim to improve programming skill over months or years, but there is a fundamental flaw in their design. While you might learn the most important functions of a language or technology stack in a month or two, you have to supplement it with additional information. Being a computer scientist isn't about the languages you know, it also requires you to think like logically, break problems down, and find new ways to solve issues. These skills come from theory classes, from delving into new aspect of CS as a whole that people ignore. This idea is even prevalent in universities, that classes that won't matter in the long run don't require you to pay attention or put effort in, but the end goal of all of these programs, and the end goal all of us should strive for is becoming a better computer scientist.

​	So why the hate for theory? I still haven't managed to answer that. Upperclassmen that I meet seem to dislike professors or think lecture was a waste of time, but breaking that down is difficult. Maybe it's professors who are disconnected from the students' point of view, or a lack of interactivity in huge lectures, but students get bored and distracted easily, even in introductory discrete math classes, where the logic could help them develop something amazing. 

​	Whatever it is, pushing students to learn this material will only improve the quality of the next generation of academics and industrial developers, programmers, and researchers. Every engineer needs the math, after all.

### Your First Day

​	It's the first day of class, and you're sitting at your desk, waiting for your set of new freshmen to come in and start on their journey into computer science. But wait, what do they already know?

​	Personally, when I walked into my very first CS class, I thought I was going to be a hacker wizard with cool terminals floating around my head and a HUD like Tony Stark, but my expectations were WILDLY out of touch with reality. I spent my first year of programming making games for a class in Visual Basic, and even that was hard to do. That is a very legitimate reality check for a lot of students, they simply don't know what they signed up for.

​	Computers in the media are extremely misconstrued, and programmers are as well. Either they're hackers in a dark room, or nerds working on some personal project, which takes away from the reality of the situation. To be fair, glamorizing computers is a great way to get kids into a class or exploring on their own, but it also makes those first few days very jarring. If you think you're going to learn how to be a hacker or a game developer and then end up talking about if-statements for 9 months, you're going to be disappointed.

​	One of my favorite aspects of the introductory CS course is a self-driven project, which seems to be a common theme. This gives students an amazing opportunity to develop as a person by developing a project related to their interests. It's also much more interesting than the generic games that people might try to make. Self-driven projects can vary in complexity greatly, a freshman in high school might make a chess game or Uno, while a freshman in college could make an interesting application using an API.

​	This self-driven concept is really something that allows students to truly find the essence of computer science, at least in its applications. They can work with data, make a game, or try their hand at a mobile app, and often end up exploring features like networking, saving files, or new libraries. This showcases a special feature to students: versatility. Students might not spend their first CS class hacking into government servers, but they can make something unique that they're proud of.

​	In addition, many teachers tend to bog students down in syntax right from the first day, which, from what I have seen, tends to harm students more than it helps them. It immediately creates a divide between the students who understand the logic or have programmed before, and the students who are just dipping their toes in. CS isn't just about programming, and it's not just about the code or the algorithms, it can also be about problem solving and resilience. Activities that emphasize these skills can be a fun way to introduce students to real computer science (think Towers of Hanoi).

​	Finally, I have seen very young students really enjoy drag-and-drop programming interfaces, since these simplify the syntax, while allowing them to change a scene as they want. For example, while volunteering with an Hour of Code event, I helped a first grader and a third grader work through a "dance party" project, where the dancers' actions could be modified using a drag-and-drop programming interface. They finished this quickly, and really enjoyed it, which might one day influence them to enter the field.

